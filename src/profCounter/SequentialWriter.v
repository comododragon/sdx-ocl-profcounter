`timescale 1ns / 1ps

module SequentialWriter(
	/* Standard pins */
	clk,
	rst_n,

	/* Base address of "log" global memory where the timestamps are saved */
	offset,
	/* Command generated by commandUnit */
	command,
	/* Timestamp value to be written */
	value,
	/* Asserted when this module is done/idling */
	idle,

	/* AXI4 Master to global memory */
	axiAWVALID,
	axiAWREADY,
	axiAWADDR,
	axiAWLEN,
	axiAWSIZE,
	axiWVALID,
	axiWREADY,
	axiWDATA,
	axiWSTRB,
	axiWLAST,
	axiBRESP,
	axiBVALID,
	axiBREADY
);

	input clk;
	input rst_n;

	input [63:0] offset;
	input [3:0] command;
	input [63:0] value;
	output idle;

	output axiAWVALID;
	input axiAWREADY;
	output [63:0] axiAWADDR;
	output [7:0] axiAWLEN;
	output [2:0] axiAWSIZE;
	output axiWVALID;
	input axiWREADY;
	output [63:0] axiWDATA;
	output [7:0] axiWSTRB;
	output axiWLAST;
	input [1:0] axiBRESP;
	input axiBVALID;
	output axiBREADY;

	// This module must be always-ready. Therefore a FIFO here will be essential
	// For now, when a transaction is being performed, all following transactions are dropped

	reg [7:0] state;
	reg [63:0] addrCounter;
	reg [63:0] wAddr;
	reg [63:0] wData;

	wire [63:0] fifoOut;
	wire fifoIsEmpty;

	assign idle = 'h00 == state && fifoIsEmpty;

	assign axiAWVALID = 'h01 == state;
	assign axiAWADDR = wAddr;
	assign axiAWLEN = 8'h01;
	assign axiAWSIZE = 3'b011;
	assign axiWVALID = 'h02 == state;
	assign axiWDATA = wData;
	assign axiWSTRB = 8'hFF;
	assign axiWLAST = 1'b1;

	assign axiBREADY = 'h03 == state;

	/* AXI4 Master write logic. This is not pipelined. Transactions are queued in the FIFO. If the FIFO is full, receiving transactions are dropped */
	always @(posedge clk) begin
		if(!rst_n) begin
			state <= 'h00;
			addrCounter <= 'h00;
			wAddr <= 'h00;
			wData <= 'h00;
		end
		else begin
			/* Idle state */
			if('h00 == state) begin
				/* FIFO is not empty, there is stuff to save */
				if(!fifoIsEmpty) begin
					/* If value is -1 (64-bit), this is an stop command. Reset address counter */
					if('hFFFFFFFFFFFFFFFF == fifoOut) begin
						addrCounter <= 'h0;
					end
					/* Else, it is a normal stamp request. Process it accordingly */
					else begin
						addrCounter <= addrCounter + 'h08;
						wAddr <= offset + addrCounter;
						wData <= fifoOut;

						state <= 'h01;
					end
				end
			end
			/* Wait for AXI4 Slave to be ready to receive address */
			else if('h01 == state) begin
				if(axiAWREADY) begin
					state <= 'h02;
				end
			end
			/* Wait for AXI4 Slave to be ready to receive data */
			else if('h02 == state) begin
				if(axiWREADY) begin
					state <= 'h03;
				end
			end
			/* Wait for AXI4 Slave to acknowledge that data was received */
			else if('h03 == state) begin
				if(axiBVALID) begin
					state <= 'h00;
				end
			end
			else begin
				state <= 'h00;
			end
		end
	end

/*
	xpm_fifo_sync#(
		.FIFO_MEMORY_TYPE("auto"),
		.FIFO_READ_LATENCY(1),
		.FIFO_WRITE_DEPTH(256),
		.READ_DATA_WIDTH(64),
		.READ_MODE("std"),
		.USE_ADV_FEATURES("0000"),
		.WRITE_DATA_WIDTH(64)
	) inst(
		.wr_clk(clk),
		.rst(~rst_n),

		.wr_en(command != 'h0),
		.rd_en('h00 == state),
		.din(('h2 == command)? 'hFFFFFFFFFFFFFFFF : value),
		.dout(fifoOut),
		.empty(fifoIsEmpty)
	);
*/

	/* Request FIFO */
	FIFO#(256, 64) fifo(
		.clk(clk),
		.rst_n(rst_n),

		/* Elements are enqueued every time command is different from 0 (i.e. STAMP command or STOP command) */
		.enqueue(command != 'h0),
		/* Elements are dequeued every time this FSM goes to idle */
		.dequeue('h00 == state),
		/* The input data is based on the command. If STAMP, the timestamp is enqueued, if STOP, -1 is enqueued */
		.back(('h2 == command)? 'hFFFFFFFFFFFFFFFF : value),
		.front(fifoOut),
		/* If FIFO is full, stamp requests are dropped (sorry for that...) */
		.full(),
		.empty(fifoIsEmpty)
	);

endmodule
