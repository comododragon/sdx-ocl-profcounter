`timescale 1ns / 1ps

`include "commands.vh"

module SequentialWriter(
	/* Standard pins */
	clk,
	rst_n,

	/* Base address of "log" global memory where the timestamps are saved */
	offset,
	/* Command generated by commandUnit */
	command,
	/* Timestamp value to be written */
	value,
	/* Asserted when this module is done/idling */
	idle,

	/* AXI4 Master to global memory */
	axiAWVALID,
	axiAWREADY,
	axiAWADDR,
	axiAWLEN,
	axiAWSIZE,
	axiWVALID,
	axiWREADY,
	axiWDATA,
	axiWSTRB,
	axiWLAST,
	axiBRESP,
	axiBVALID,
	axiBREADY
);

	input clk;
	input rst_n;

	input [63:0] offset;
	input [3:0] command;
	input [63:0] value;
	output idle;

	output axiAWVALID;
	input axiAWREADY;
	output [63:0] axiAWADDR;
	output [7:0] axiAWLEN;
	output [2:0] axiAWSIZE;
	output axiWVALID;
	input axiWREADY;
	output [63:0] axiWDATA;
	output [7:0] axiWSTRB;
	output axiWLAST;
	input [1:0] axiBRESP;
	input axiBVALID;
	output axiBREADY;

	reg [7:0] state;
	reg hold;
	reg [63:0] addrCounter;
	reg [63:0] wAddr;
	reg [63:0] wData;

	wire fifoEnqueue;
	wire fifoDequeue;
	wire [63:0] fifoIn;
	wire [63:0] fifoOut;
	wire fifoIsEmpty;

	assign idle = 'h00 == state && fifoIsEmpty;

	assign axiAWVALID = 'h01 == state;
	assign axiAWADDR = wAddr;
	assign axiAWLEN = 8'h01;
	assign axiAWSIZE = 3'b011;
	assign axiWVALID = 'h02 == state;
	assign axiWDATA = wData;
	assign axiWSTRB = 8'hFF;
	assign axiWLAST = 1'b1;

	assign axiBREADY = 'h03 == state;

	/* Hold logic. If COMM_HOLD is received, FIFO dequeuing is paused until a COMM_FINISH is issued */
	always @(posedge clk) begin
		if(!rst_n) begin
			hold <= 1'b0;
		end
		else begin
			/* Hold was issued, FIFO dequeuing is paused */
			if(`COMM_HOLD == command)
				hold <= 1'b1;
			/* Finish was issued, FIFO dequeuing is released */
			else if(`COMM_FINISH == command)
				hold <= 1'b0;
		end
	end

	/* AXI4 Master write logic. This is not pipelined. Transactions are queued in the FIFO. If the FIFO is full, receiving transactions are dropped */
	always @(posedge clk) begin
		if(!rst_n) begin
			state <= 'h00;
			addrCounter <= 'h00;
			wAddr <= 'h00;
			wData <= 'h00;
		end
		else begin
			/* Idle state */
			if('h00 == state) begin
				/* FIFO is not empty, there is stuff to save */
				if(!hold && !fifoIsEmpty) begin
					/* If value is -1 (64-bit), this is a COMM_FINISH command. Reset address counter */
					if('hFFFFFFFFFFFFFFFF == fifoOut) begin
						addrCounter <= 'h0;
					end
					/* Else, it is a normal stamp request. Process it accordingly */
					else begin
						addrCounter <= addrCounter + 'h08;
						wAddr <= offset + addrCounter;
						wData <= fifoOut;

						state <= 'h01;
					end
				end
			end
			/* Wait for AXI4 Slave to be ready to receive address */
			else if('h01 == state) begin
				if(axiAWREADY) begin
					state <= 'h02;
				end
			end
			/* Wait for AXI4 Slave to be ready to receive data */
			else if('h02 == state) begin
				if(axiWREADY) begin
					state <= 'h03;
				end
			end
			/* Wait for AXI4 Slave to acknowledge that data was received */
			else if('h03 == state) begin
				if(axiBVALID) begin
					state <= 'h00;
				end
			end
			else begin
				state <= 'h00;
			end
		end
	end

	/* Elements are enqueued every time command is not COMM_NOP or COMM_HOLD */
	assign fifoEnqueue = command != `COMM_NOP && command != `COMM_HOLD;
	/* Elements are dequeued every time this FSM goes to idle and hold period is over (if applicable) */
	assign fifoDequeue = 'h00 == state && !hold;
	/* The input data is based on the command. If COMM_STAMP, the timestamp is enqueued, if COMM_FINISH, -1 is enqueued */
	/* For other values different from COMM_NOP and COMM_HOLD, the checkpoint ID is saved with the timestamp (COMM_CHECKPOINT) */
	assign fifoIn = (`COMM_FINISH == command)? 'hFFFFFFFFFFFFFFFF : ((`COMM_STAMP == command)? value : {command[3:0] - 4'h1, value[59:0]});

	/* Request FIFO */
	FIFO#(256, 64) fifo(
		.clk(clk),
		.rst_n(rst_n),

		.enqueue(fifoEnqueue),
		.dequeue(fifoDequeue),
		.back(fifoIn),
		.front(fifoOut),
		/* If FIFO is full, stamp requests are dropped (sorry for that...) */
		.full(),
		.empty(fifoIsEmpty)
	);

endmodule
